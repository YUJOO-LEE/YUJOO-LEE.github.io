---
layout: post
title:  프로그래머스 연습문제 Day10
date:   2022-09-29 18:26:03 +0900
comments : true
categories: Note
tags: [programmers, algorithm, javascript]
---


척척하고 잘 하고 싶다.

언제쯤 그렇게 될까?

<br><br>
<hr>
<br><br>

### 시저 암호

<br>

**문제 설명**

어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 "AB"는 1만큼 밀면 "BC"가 되고, 3만큼 밀면 "DE"가 됩니다. "z"는 1만큼 밀면 "a"가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.

<br>

**제한 조건**

- 공백은 아무리 밀어도 공백입니다.

- s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.

- s의 길이는 8000이하입니다.

- n은 1 이상, 25이하인 자연수입니다.

<br>

**입출력 예**

s | n | result
-- | --- | ----
"AB" | 1 | "BC"
-- | --- | ----
"z" | 1 | "a"
-- | --- | ----
"a B z" | 4 | "e F d"

<br><br>

```javascript
function solution(s, n) {
  return [...s].map((v)=> 
    v === ' ' ? v 
      : String.fromCharCode(v.charCodeAt(0) + n > 122 
        || (v.charCodeAt(0) <= 90 && v.charCodeAt(0) + n > 90)
        ? v.charCodeAt(0) + n -26 
        : v.charCodeAt(0) + n))
    .join('');
}
```

<br>

한 줄로 하고 싶어서 쓸데없이 길어진 느낌이 있다.

<br>

```javascript
function solution(s, n) {
  let answer = '';
  for (let i = 0 ; i < s.length ; i++){
    if (s[i] === ' ') {
      answer += ' ';
      continue;
    }

    const code = s.charCodeAt(i) + n;
    if(s.charCodeAt(i) <= 90 && code > 90 || code > 122) {
      answer += String.fromCharCode(code - 26);
    } else {
      answer += String.fromCharCode(code);
    }
  }
  return answer;
}
```

<br>

어렵네...

아무튼 덕분에 `charCodeAt()`과 `String.fromCahrCode()`의 사용법을 배웠다.

<br><br>
<hr>
<br><br>

### 비밀지도

<br>

**문제 설명**

네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

- 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.

- 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.

- "지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.

- 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.

![secret map](/img/22-09-29/secret8.png)

네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.

<br>

**입력 형식**

입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.

- 1 ≦ n ≦ 16

- arr1, arr2는 길이 n인 정수 배열로 주어진다.

- 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.

<br>

**출력 형식**

원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.

<br>

**입출력 예제**

매개변수 | 값
---- | ----
n | 5
---- | ----
arr1 | [9, 20, 28, 18, 11]
---- | ----
arr2 | [30, 1, 21, 17, 28]
---- | ----
출력 | ["#####","# # #", "### #", "# ##", "#####"]

매개변수 | 값
---- | ----
n | 6
---- | ----
arr1 | [46, 33, 33 ,22, 31, 50]
---- | ----
arr2 | [27 ,56, 19, 14, 14, 10]
---- | ----
출력 | ["######", "### #", "## ##", " #### ", " #####", "### # "]

<br><br>

```javascript
function solution(n, arr1, arr2) {
  arr1 = arr1.map(v => v.toString(2).padStart(n, 0));
  arr2 = arr2.map(v => v.toString(2).padStart(n, 0).split(''));
  return arr1.map((a,i)=> [...a].map((b,j) => 
    !(Number(b) + Number(arr2[i][j])) ? ' ' : '#').join(''));
}
```

<br>

둘다 문자로 바꿔서 한자리씩 비교하기.

단순무식 해 보여도 최대한 노력한 결과...

<br><br>
<hr>
<br><br>

### 최소직사각형

<br>

**문제 설명**

명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.

아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.

명함 번호 | 가로 길이 | 세로 길이
---- | ---- | ----
1 | 60 | 50
---- | ---- | ----
2 | 30 | 70
---- | ---- | ----
3 | 60 | 30
---- | ---- | ----
4 | 80 | 40

가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.

모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

<br>

**제한사항**

- sizes의 길이는 1 이상 10,000 이하입니다.

- sizes의 원소는 [w, h] 형식입니다.

- w는 명함의 가로 길이를 나타냅니다.

- h는 명함의 세로 길이를 나타냅니다.

- w와 h는 1 이상 1,000 이하인 자연수입니다.

<br>

**입출력 예**

sizes | result
---- | ----
[[60, 50], [30, 70], [60, 30], [80, 40]] | 4000
---- | ----
[[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]] | 120
---- | ----
[[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]] | 133

<br>

**입출력 예 설명**

- 입출력 예 #1    
문제 예시와 같습니다.

- 입출력 예 #2    
명함들을 적절히 회전시켜 겹쳤을 때, 3번째 명함(가로: 8, 세로: 15)이 다른 모든 명함보다 크기가 큽니다. 따라서 지갑의 크기는 3번째 명함의 크기와 같으며, 120(=8 x 15)을 return 합니다.

- 입출력 예 #3    
명함들을 적절히 회전시켜 겹쳤을 때, 모든 명함을 포함하는 가장 작은 지갑의 크기는 133(=19 x 7)입니다.

<br><br>

```javascript
function solution(sizes) {
  const newSizes = sizes.map(v=> v.sort((a,b) => a-b));
  return biggest(newSizes, 0) * biggest(newSizes, 1);
}

function biggest(arr, index) {
  return arr.reduce((a,c) => c[index] > a ? c[index] : a, 0);
}
```

<br>

오늘 한 것 중에는 그나마 제일 예쁘게 생긴 듯..

<br><br>
