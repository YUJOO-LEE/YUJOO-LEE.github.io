---
layout: post
title:  프로그래머스 연습문제 Day12
date:   2022-10-06 23:59:03 +0900
comments : true
categories: Note
tags: [programmers, algorithm, javascript]
---


포트폴리오 제작하느라 살짝 소홀했던 문제풀기.



<br><br>
<hr>
<br><br>

### 두 개 뽑아서 더하기

<br>

**문제 설명**

정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.

<br>

**제한사항**

- numbers의 길이는 2 이상 100 이하입니다.

- numbers의 모든 수는 0 이상 100 이하입니다.

<br>

**입출력 예**

numbers | result
---- | ----
[2,1,3,4,1] | [2,3,4,5,6,7]
---- | ----
[5,0,2,7] | [2,5,7,9,12]

<br>

**입출력 예 설명**

- 입출력 예 #1

2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.)

3 = 2 + 1 입니다.

4 = 1 + 3 입니다.

5 = 1 + 4 = 2 + 3 입니다.

6 = 2 + 4 입니다.

7 = 3 + 4 입니다.

따라서 [2,3,4,5,6,7] 을 return 해야 합니다.

<br>

- 입출력 예 #2

2 = 0 + 2 입니다.

5 = 5 + 0 입니다.

7 = 0 + 7 = 5 + 2 입니다.

9 = 2 + 7 입니다.

12 = 5 + 7 입니다.

따라서 [2,5,7,9,12] 를 return 해야 합니다.

<br><br>

```javascript
function solution(numbers) {
  const answer = [];
  for (let i = 0; i < numbers.length; i++){
    for (let j = i + 1; j < numbers.length; j++) {
      answer.push(numbers[i] + numbers[j]);
    }
  }
  return [...new Set(answer)].sort((a,b) => a-b);
}
```

<br>

더할수 있는 수를 다 더해서 중복값을 제거햇다.

`new Set()`은 중복값 제거할때 말고는 써 본 적이 없는데 언제 쓰는걸까?

<br><br>
<hr>
<br><br>

### 2016년

**문제 설명**

2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 "TUE"를 반환하세요.

<br>

**제한 조건**

2016년은 윤년입니다.

2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)

<br>

**입출력 예**

a | b | result
-- | -- | ---
5 | 24 | "TUE"

<br><br>

```javascript
function solution(a, b) {
  const weekday = ['SUN','MON','TUE','WED','THU','FRI','SAT']
  const today = new Date(`2016-${a}-${b}`);
  return weekday[today.getDay()];
}
```

<br>

처음 보고 아 Date에서 뽑아내면 되겠네 했는데, 이러면 알고리즘 문제를 푸는 의미가 없는 건가 싶었다.

<br>

```javascript
function solution(a, b) {
  const weekday = ['THU','FRI','SAT','SUN','MON','TUE','WED'];
  const month = [31,29,31,30,31,30,31,31,30,31,30,31];
  let dayTotal;

  if(a === 1) {
    return weekday[b % 7];
  } else {
    dayTotal = month.slice(0, a - 1).reduce((a, b) => a + b) + b;
    return weekday[dayTotal % 7];
  }
}
```

<br>

1월 1일 금요일부터 시작하므로 금요일을 인덱스 1에 놓아주고, 시작 날짜 기준으로 지나온 날짜수를 다 더해서 7으로 나눈 나머지를 찾았다.

`slice()`사용할때 1월은 month에서 해당되는 인덱스가 없어서 따로 뺐다.

<br><br>
<hr>
<br><br>

### 폰켓몬

**문제 설명**

당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.

홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.

- 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택

- 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택

- 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택

- 두 번째(1번), 세 번째(2번) 폰켓몬을 선택

- 두 번째(1번), 네 번째(3번) 폰켓몬을 선택

- 세 번째(2번), 네 번째(3번) 폰켓몬을 선택

이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.

당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.

<br>

**제한사항**

- nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.

- nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.

- 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.

- 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.

<br>

**입출력 예**

nums | result
---- | -----
[3,1,2,3] | 2
---- | -----
[3,3,3,2,2,4] | 3
---- | -----
[3,3,3,2,2,2] | 2

<br>

**입출력 예 설명**

- 입출력 예 #1

문제의 예시와 같습니다.

<br>

- 입출력 예 #2

6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.

가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.

<br>

- 입출력 예 #3

6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.

가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.

<br><br>

```javascript
function solution(nums) {
  const type = [...new Set(nums)].length;
  const total = Math.ceil(nums.length / 2);
  return type > total ? total : type;
}
```

<br>

정성을 들인 문제에 비해 짧은 코드라 정성이 모자라 보이려나..

중복값을 제거해서 종류의 수를 구하고 선택할 수 있는 기회 N/2와 비교해서 더 높은 값을 반환했다.

설명대로의 풀이가 아닌 다른 빠른 풀이가 떠오르면 기분이 좋다.

<br><br>

