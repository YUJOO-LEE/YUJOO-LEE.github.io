---
layout: post
title:  학원 수업 내용 Day28
date:   2022-10-30 02:50:57 +0900
comments : true
categories: Note
tags: [decodelab, react, redux, terminal, github]
---

### generator


비동기 함수의 동기작업을 처리하기 위해 그동안은 `promise`, `then`, `asyn`, `await` 등의 구문을 사용했었다.

위의 구문을 사용하면 앞에서 일어난 상황이 끝난 직후 다음 상황이 실행하게 되는데, 이렇게 즉시 실행하지 않고 원하는 타이밍에 실행하도록 하려면 `generator` 를 사용해야 한다.


#### 사용 방법

먼저 순차적으로 실행하고 싶은 내부 함수들을 작성한다.

```javascript
function 내부함수1() {
  console.log('text1');
  return '리턴값1';
}
function 내부함수2() {
  console.log('text2');
  return '리턴값2';
}
```

그리고 이 내부 함수들을 묶을 함수를 만드는데, 함수 선언 시 `*` 를 붙여 제너레이터 함수로 만든다.

그리고 내부 함수들을 실행을 원하는 순서대로 불러오는데, 앞에 `yield` 라는 구문을 붙여준다.

이렇게 제너레이터로 선언된 함수의 내부 함수들은 호출하기 전까지 실행되지 않고 기다리게 된다.

마지막으로 해당 제너레이터 함수를 실행하기 위해 이 함수를 담을 변수를 만든다.

```javascript
function* 함수() {
  yield 내부함수1();
  yield 내부함수2();
}

const 함수를_담은_변수 = 함수();
```

이제 원하는 타이밍에 순차적으로 불러오기만 하면 된다.

먼저 만든 제너레이터 함수에 `.next()`를 붙이면 함수 내부에 불러온 순서대로 하나씩 실행한다.

```javascript
const 내부함수1_실행결과를_담은_변수 = 함수를_담은_변수.next();
// 내부함수 1의 내용으로 console.log(text1) 이 실행되어 콘솔에 text1이 출력됨
console.log(내부함수1_실행결과를_담은_변수); 
// 내부함수 1의 실행 결과가 콘솔에 출력됨
```

첫번째로 `.next()`를 실행하면 `yield` 가 붙은 내부 함수 중 가장 상위의 함수가 호출된다.

여기서는 내부 함수의 `console.log(text1)` 이 실행되어 콘솔에 text1이 출력된다.

그리고 이 변수 자체를 콘솔에 출력시키면, 내부함수의 실행 결과가 객체 형태로 출력된다.

객체는 내부에 두개의 프로퍼티를 가지고 있는데, 첫번째는 done 으로 제너레이터 함수의 실행완료 여부를 알려주는 값이 담겨있다.

아직 실행이 완료되지 않았기 때문에 이 값은 `false` 가 담겨있다.

그리고 두번째는 내부함수에서 `return` 한 값인 `리턴값1`이 담겨있어서 해당 값을 활용할 수 있게 된다.

```javascript
const 내부함수2_실행결과를_담은_변수 = 함수를_담은_변수.next();
console.log(내부함수2_실행결과를_담은_변수);
```

그리고 두번째로 실행하면, 방금 전 함수의 다음 함수인 두번째 함수를 실행한다.

```javascript
const 내부함수2_실행결과를_담은_변수 = 함수를_담은_변수.next();
console.log(내부함수2_실행결과를_담은_변수);
```

한 번 더 `next()` 를 실행해서 실행한 횟수가 내부함수의 갯수보다 더 많아지면, 에러가 나지는 않고 이미 종료된 함수이기 때문에 결과값으로 done이 `true`값으로 담겨있고 value값은 `undefined`로 비어있는 상태로 출력된다.

<br>

### Redux-saga

정리중...

너무 졸려서 내일 해야지...

